"""
Author: Jean-Baptiste Saulnier
Date: 2024-12-05

This module defines the `BacteriaBody` class that simulates the internal forces between nodes of bacterial cells, including both 
spring-like interactions and follower mechanisms that maintain distances between the nodes.
It handles the adjustment of node positions to preserve the structure of the bacterium during 
the simulation and applies stiffness forces to simulate mechanical interactions.
"""
import numpy as np


class BacteriaBody:
    """
    Manages the internal distances between the nodes of each bacteria.
    
    This class is responsible for modeling the internal mechanics of a bacterium,
    particularly the forces between its nodes and the way the nodes move relative
    to each other to maintain structure and stability.

    Attributes:
    -----------
    par : object
        Instance of the `Parameters` class containing simulation parameters such as node count, 
        time step, and spring constants.
    gen : object
        Instance of a class managing the positions and states of the bacterial nodes during the simulation.
    pha : object
        Instance of a class managing the positions and states of the phantom bacterial nodes for additional effects.
    dir : object
        Instance of a class managing directional information of bacterial nodes, including alignment and directional forces.
    stiffness_forces : ndarray
        Array storing the stiffness forces applied between nodes, shaped `(2, n_nodes-1, n_bact)`. The 2 corresponds to the 
        x and y direction, `n_nodes-1` for the spring force between consecutive nodes, and `n_bact` for the number of bacteria.
    """
    def __init__(self, inst_par, inst_gen, inst_pha, inst_dir):
        # Store references to external class instances
        self.par = inst_par
        self.gen = inst_gen
        self.pha = inst_pha
        self.dir = inst_dir

        # Initialize the stiffness forces matrix to store forces between nodes
        # Shape: (2, n_nodes-1, n_bact) -> 2 for x and y directions, n_nodes-1 for node-to-node connections, n_bact for number of bacteria
        self.stiffness_forces = np.zeros((2, self.par.n_nodes-1, self.par.n_bact), dtype=self.par.float_type)


    def head_follower(self):
        """
        Each node follows the node in front of it to keep the same distance
        between nodes after the head moves. This method adjusts the position of each node 
        based on the movement of the node ahead of it.

        This ensures that the distances between nodes remain constant after the head moves.
        """
        # Loop over all nodes (except the first node) to adjust their positions
        for i in range(1, self.par.n_nodes):
            
            # Update the direction of the nodes (distance and direction vectors between nodes)
            self.dir.set_nodes_direction(data=self.pha.data_phantom)

            # Adjust the positions of nodes based on the difference in distances
            # between the current distance and the desired distance (self.par.d_n)
            self.gen.data[:, i, :] += (self.dir.nodes_distance[i, :] - self.par.d_n) * self.dir.nodes_direction[:, i, :]
            self.pha.data_phantom[:, i, :] += (self.dir.nodes_distance[i, :] - self.par.d_n) * self.dir.nodes_direction[:, i, :]


    def nodes_spring(self):
        """
        Apply spring forces between the nodes of the bacteria to simulate the 
        internal mechanical interactions between nodes.

        This method models the forces generated by a spring between each pair of nodes,
        and updates the positions of the nodes based on these forces.
        """
        # Loop through the number of iterations to apply the spring force calculation
        # For each node, spring forces are applied based on the node's position and the stiffness constant.
        for i in range(self.par.n_nodes * 5):
            
            # Update the direction and distance between nodes
            self.dir.set_nodes_direction()

            # Calculate the spring forces between nodes (Hooke's law: F = -k * (x - x_0))
            # Apply the stiffness constant 'k_s' and the difference between the current and desired distances
            # between nodes. The resulting forces are stored in the stiffness_forces array.
            self.stiffness_forces[:, :, :] = -self.par.k_s * (self.dir.nodes_direction[:, 1:, :] * self.dir.nodes_distance[1:, :] - self.dir.nodes_direction[:, 1:, :] * self.par.d_n)

            # Update the positions of the nodes (both the generator data and the phantom data)
            # The force is multiplied by the square of the time step (dt^2) to update the positions.
            self.gen.data[:, :-1, :self.gen.first_index_prey_bact] += self.stiffness_forces[:, :, :self.gen.first_index_prey_bact] * self.par.dt
            self.gen.data[:, 1:, :self.gen.first_index_prey_bact] -= self.stiffness_forces[:, :, :self.gen.first_index_prey_bact] * self.par.dt
            self.pha.data_phantom[:, :-1, :self.gen.first_index_prey_bact] += self.stiffness_forces[:, :, :self.gen.first_index_prey_bact] * self.par.dt
            self.pha.data_phantom[:, 1:, :self.gen.first_index_prey_bact] -= self.stiffness_forces[:, :, :self.gen.first_index_prey_bact] * self.par.dt
